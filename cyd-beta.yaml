esphome:
  name: cyd-beta
  friendly_name: CYD Beta

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret ha_api

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "Cyd-Beta Fallback Hotspot"
    password: !secret fallback_hotspot

captive_portal:

################################################################
# Hardware Configuration for the CYD (Cheap Yellow Display)
################################################################

i2c:
  - sda: 27
    scl: 22
    scan: true

spi:
  # SPI bus for the ILI9341 TFT
  - id: tft
    clk_pin: 14
    mosi_pin: 13
    miso_pin:
      number: 12
      ignore_strapping_warning: true

  # SPI bus for the XPT2046 Touch
  - id: touch
    clk_pin: 25
    mosi_pin: 32
    miso_pin: 39

output:
  - id: backlight_pwm
    platform: ledc
    pin: 21

  - id: output_red
    platform: ledc
    pin: 4
    inverted: true

  - id: output_green
    platform: ledc
    pin: 16
    inverted: true

  - id: output_blue
    platform: ledc
    pin: 17
    inverted: true

light:
  - id: backlight
    platform: monochromatic
    output: backlight_pwm
    name: "Display Backlight"
    restore_mode: ALWAYS_ON

  - id: led
    platform: rgb
    red: output_red
    green: output_green
    blue: output_blue
    restore_mode: ALWAYS_OFF

################################################################
# Touchscreen Configuration
################################################################
touchscreen:
  - id: main_touchscreen
    platform: xpt2046
    spi_id: touch
    cs_pin: 33
    interrupt_pin: 36
    threshold: 400
    calibration:
      x_min: 280
      x_max: 3860
      y_min: 340
      y_max: 3860
    transform:
      mirror_x: true

################################################################
# Display Configuration
################################################################
display:
  - id: main_display
    platform: ili9xxx
    model: ILI9341
    spi_id: tft
    cs_pin:
      number: 15
      ignore_strapping_warning: true
    dc_pin:
      number: 2
      ignore_strapping_warning: true
    invert_colors: false
    auto_clear_enabled: false
    rotation: 90
    pages:
      - id: critical_moisture
        lambda: |-
          // A helper struct and some inline helper lambdas
          struct StatusInfo {
            const char* text;
            Color color;
            bool needs_blink;
          };

          auto safe_clear = [](display::Display& it) {
            it.fill(Color::BLACK);
          };

          auto should_blink = []() -> bool {
            return ((millis() / 150) % 2) == 0;
          };

          auto safe_value = [](float value) -> float {
            if (value < 0.0f) return 0.0f;
            if (value > 100.0f) return 100.0f;
            return value;
          };

          auto truncate_text = [](const char* text, size_t max_len) -> std::string {
            std::string str(text);
            if (str.length() > max_len)
              return str.substr(0, max_len - 3) + "...";
            return str;
          };

          auto get_status = [&](float value) -> StatusInfo {
            if (value >= 61) return {"DROWNING!", id(retro_red), true};
            if (value <= 9)  return {"DYING!",    id(retro_red), true};
            if (value <= 19) return {"DRY!",      id(retro_orange), true};
            if (value <= 25) return {"WATER SOON",id(retro_yellow), true};
            return {"GOOD!", id(retro_green), false};
          };

          safe_clear(it);
          it.print(10, 20, id(roboto_large), id(retro_red), "CRITICAL STATUS");

          int y_pos = 80;
          bool has_critical = false;

          // A local function for each sensor
          auto check_critical = [&](const char *plant, optional<float> mo_val, Color plant_color) {
            if (!mo_val.has_value()) {
              ESP_LOGW("moisture", "No value for sensor %s", plant);
              return;
            }
            float value = safe_value(mo_val.value());
            if (value <= 19 || value >= 61) {
              std::string name = truncate_text(plant, 15);
              StatusInfo stat = get_status(value);

              // Overwrite region (to prevent old text from interfering)
              it.filled_rectangle(10, y_pos, 220, 60, Color::BLACK);

              if (should_blink()) {
                it.printf(10, y_pos, id(roboto_small), plant_color, "%s: %.1f%%", name.c_str(), value);
                it.print(10, y_pos + 30, id(roboto_small), stat.color, stat.text);
              }
              y_pos += 70;
              has_critical = true;
            }
          };

          // Check each plant/sensor
          check_critical("Little Cado", id(soil_moisture_1).state, id(retro_blue));
          check_critical("Cannabis", id(soil_moisture_2).state, id(retro_orange));
          check_critical("Hibiscus", id(soil_moisture_3).state, id(retro_yellow));
          check_critical("Succulent Table", id(soil_moisture_4).state, id(retro_teal));
          check_critical("Spider Plant", id(soil_moisture_5).state, id(retro_cyan));

          if (!has_critical) {
            it.print(10, y_pos, id(roboto_medium), id(retro_green), "All Plants OK!");
          }

      - id: moisture_page1
        lambda: |-
          struct StatusInfo {
            const char* text;
            Color color;
            bool needs_blink;
          };

          auto safe_clear = [](display::Display& it) {
            it.fill(Color::BLACK);
          };

          auto should_blink = []() -> bool {
            return ((millis() / 150) % 2) == 0;
          };

          auto safe_value = [](float value) -> float {
            if (value < 0.0f) return 0.0f;
            if (value > 100.0f) return 100.0f;
            return value;
          };

          auto truncate_text = [](const char* text, size_t max_len) -> std::string {
            std::string str(text);
            if (str.length() > max_len)
              return str.substr(0, max_len - 3) + "...";
            return str;
          };

          auto get_status = [&](float value) -> StatusInfo {
            if (value >= 61) return {"DROWNING!", id(retro_red), true};
            if (value <= 9)  return {"DYING!",    id(retro_red), true};
            if (value <= 19) return {"DRY!",      id(retro_orange), true};
            if (value <= 25) return {"WATER SOON",id(retro_yellow), true};
            return {"GOOD!", id(retro_green), false};
          };

          safe_clear(it);
          it.print(10, 20, id(roboto_large), id(retro_green), "PLANT MOISTURE 1/3");

          int y_pos = 80;

          auto print_status = [&](const char *plant, optional<float> mo_val, Color plant_color) {
            if (!mo_val.has_value()) {
              ESP_LOGW("moisture", "No value for sensor %s", plant);
              return;
            }
            float value = safe_value(mo_val.value());
            std::string name = truncate_text(plant, 15);
            StatusInfo stat = get_status(value);

            it.filled_rectangle(10, y_pos, 220, 60, Color::BLACK);

            if (!stat.needs_blink || should_blink()) {
              it.printf(10, y_pos, id(roboto_small), plant_color, "%s: %.1f%%", name.c_str(), value);
              it.print(10, y_pos + 30, id(roboto_small), stat.color, stat.text);
            }
            y_pos += 70;
          };

          print_status("Little Cado", id(soil_moisture_1).state, id(retro_blue));
          print_status("Cannabis", id(soil_moisture_2).state, id(retro_orange));

      - id: moisture_page2
        lambda: |-
          struct StatusInfo {
            const char* text;
            Color color;
            bool needs_blink;
          };

          auto safe_clear = [](display::Display& it) {
            it.fill(Color::BLACK);
          };

          auto should_blink = []() -> bool {
            return ((millis() / 150) % 2) == 0;
          };

          auto safe_value = [](float value) -> float {
            if (value < 0.0f) return 0.0f;
            if (value > 100.0f) return 100.0f;
            return value;
          };

          auto truncate_text = [](const char* text, size_t max_len) -> std::string {
            std::string str(text);
            if (str.length() > max_len)
              return str.substr(0, max_len - 3) + "...";
            return str;
          };

          auto get_status = [&](float value) -> StatusInfo {
            if (value >= 61) return {"DROWNING!", id(retro_red), true};
            if (value <= 9)  return {"DYING!",    id(retro_red), true};
            if (value <= 19) return {"DRY!",      id(retro_orange), true};
            if (value <= 25) return {"WATER SOON",id(retro_yellow), true};
            return {"GOOD!", id(retro_green), false};
          };

          safe_clear(it);
          it.print(10, 20, id(roboto_large), id(retro_green), "PLANT MOISTURE 2/3");

          int y_pos = 80;

          auto print_status = [&](const char *plant, optional<float> mo_val, Color plant_color) {
            if (!mo_val.has_value()) {
              ESP_LOGW("moisture", "No value for sensor %s", plant);
              return;
            }
            float value = safe_value(mo_val.value());
            std::string name = truncate_text(plant, 15);
            StatusInfo stat = get_status(value);

            it.filled_rectangle(10, y_pos, 220, 60, Color::BLACK);

            if (!stat.needs_blink || should_blink()) {
              it.printf(10, y_pos, id(roboto_small), plant_color, "%s: %.1f%%", name.c_str(), value);
              it.print(10, y_pos + 30, id(roboto_small), stat.color, stat.text);
            }
            y_pos += 70;
          };

          print_status("Hibiscus", id(soil_moisture_3).state, id(retro_yellow));
          print_status("Succulent Table", id(soil_moisture_4).state, id(retro_teal));

      - id: moisture_page3
        lambda: |-
          struct StatusInfo {
            const char* text;
            Color color;
            bool needs_blink;
          };

          auto safe_clear = [](display::Display& it) {
            it.fill(Color::BLACK);
          };

          auto should_blink = []() -> bool {
            return ((millis() / 150) % 2) == 0;
          };

          auto safe_value = [](float value) -> float {
            if (value < 0.0f) return 0.0f;
            if (value > 100.0f) return 100.0f;
            return value;
          };

          auto truncate_text = [](const char* text, size_t max_len) -> std::string {
            std::string str(text);
            if (str.length() > max_len)
              return str.substr(0, max_len - 3) + "...";
            return str;
          };

          auto get_status = [&](float value) -> StatusInfo {
            if (value >= 61) return {"DROWNING!", id(retro_red), true};
            if (value <= 9)  return {"DYING!",    id(retro_red), true};
            if (value <= 19) return {"DRY!",      id(retro_orange), true};
            if (value <= 25) return {"WATER SOON",id(retro_yellow), true};
            return {"GOOD!", id(retro_green), false};
          };

          safe_clear(it);
          it.print(10, 20, id(roboto_large), id(retro_green), "PLANT MOISTURE 3/3");

          int y_pos = 80;

          auto print_status = [&](const char *plant, optional<float> mo_val, Color plant_color) {
            if (!mo_val.has_value()) {
              ESP_LOGW("moisture", "No value for sensor %s", plant);
              return;
            }
            float value = safe_value(mo_val.value());
            std::string name = truncate_text(plant, 15);
            StatusInfo stat = get_status(value);

            it.filled_rectangle(10, y_pos, 220, 60, Color::BLACK);

            if (!stat.needs_blink || should_blink()) {
              it.printf(10, y_pos, id(roboto_small), plant_color, "%s: %.1f%%", name.c_str(), value);
              it.print(10, y_pos + 30, id(roboto_small), stat.color, stat.text);
            }
            y_pos += 70;
          };

          print_status("Spider Plant", id(soil_moisture_5).state, id(retro_cyan));


################################################################
# Colors and Fonts
################################################################
color:
  - id: retro_red
    hex: FF1744
  - id: retro_orange
    hex: FF9100
  - id: retro_yellow
    hex: FFD600
  - id: retro_green
    hex: 00E676
  - id: retro_blue
    hex: 00B0FF
  - id: retro_cyan
    hex: 00FFFF
  - id: retro_teal
    hex: 00BFA5

font:
  - file: "Roboto-Regular.ttf"
    id: roboto_small
    size: 24
  - file: "Roboto-Regular.ttf"
    id: roboto_medium
    size: 36
  - file: "Roboto-Regular.ttf"
    id: roboto_large
    size: 38

################################################################
# Moisture Sensors
################################################################
sensor:
  - platform: homeassistant
    id: soil_moisture_1
    entity_id: sensor.gw1100b_soil_moisture_1

  - platform: homeassistant
    id: soil_moisture_2
    entity_id: sensor.gw1100b_soil_moisture_2

  - platform: homeassistant
    id: soil_moisture_3
    entity_id: sensor.gw1100b_soil_moisture_3

  - platform: homeassistant
    id: soil_moisture_4
    entity_id: sensor.gw1100b_soil_moisture_4

  - platform: homeassistant
    id: soil_moisture_5
    entity_id: sensor.gw1100b_soil_moisture_5

################################################################
# Update Intervals
################################################################
interval:
  # Update the display quickly (for blinking text, etc.)
  - interval: 500ms
    then:
      - component.update: main_display

  # Cycle through pages every 6 seconds
  - interval: 6s
    then:
      - display.page.show_next: main_display
